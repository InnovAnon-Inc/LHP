






<div>
	<h6>base frequency</h6>
	<input id="bf" type="number" value="432">
</div>

<div>
	<!-- select type: equal tempered, just, odd-limit, prime-limit, custom, etc -->
	<h6>number of notes in scale</h6>
	<input id="scale" type="number" value="12">
	<h6>note 1 ratio</h6>
	<input id="scale1" type="text" value="1/1">
	<h6>note 2 ratio</h6>
	<input id="scale2" type="text" value="16/15">
	<!-- ... 1 - 12 -->
</div>

<div>
	<h6></h6>
	<input id="">
</div>





<!-- TODO info about heart rates -->
<input id="tempo">

<!-- TODO info about moods -->
<input id="mode">

<!-- TODO select subaudial note delivery mechanism :P
     - monaural for single-channel
     - binaural for headphones
     - isochronic for single-channel
     - tempo phase shifting for headphones -->

<!-- TODO how to apply visual isochronic pulses? -->

<!-- update visuals on beat,
     show "important" visuals on skipped beats
     (i.e., show yantra and display kali subliminally) -->





<canvas width="200" height="200">
</canvas>

<script>
	
var baseFrequency = document.getElementById ('bf').value;
var scale = new Array (12);
var mode  = new Array (7);

/*
var chords = [
	[1, 3, 5], // major
	[1, 3, 5, 7], // seventh
	[1, 3, 6] // minor ?
];
*/

/*
var extendedChordForms ...

*/

// need basic chord progression
// add more intervals to basic chords... how?
// generate melody from within those extended arpeggios

// melody-driven approach?
// generate melody from within scale and basic chord arpeggio
// when hitting a scale note that's not in the chord,
// add that interval to the extended chords
// then back to the harmony-driven approach

// each "line":
// given a measure, make n divisions
// 



function Player (measureLengths, ) {
	this.measureLengths = measureLengths;
}



// all lines share measures of length n1, n2, n3, etc
// each line divides measures differently to get its beats (i.e., different time siggies)
// 

</script>





<script>
var context = new AudioContext;
	console.log(context.sampleRate);
	console.log(context.destination.channelCount);
	
	
function Kick(context, freq, gainV) {
	this.context = context;
	this.freq = freq;
	this.gainV = gainV;
};

Kick.prototype.setup = function() {
	this.osc = this.context.createOscillator();
	this.gain = this.context.createGain();
	this.osc.connect(this.gain);
	this.gain.connect(this.context.destination)
};

Kick.prototype.trigger = function(time) {
	this.setup();

	this.osc.frequency.setValueAtTime(this.freq, time);
	this.gain.gain.setValueAtTime(this.gainV, time);
	this.gain.gain.setValueAtTime(1, time);

	this.osc.frequency.exponentialRampToValueAtTime(0.01, time + 1 / 7.83);
	this.gain.gain.exponentialRampToValueAtTime(0.01, time + 1 / 7.83);

	this.osc.start(time);

	this.osc.stop(time + 1 / 7.83);
};

var kicks = new Array(2);

for (var i = 0; i < kicks.length; i++)
	kicks[i] = new Kick(context, 7.83 * (1 + i), 1 - i / kicks.length);
var now = context.currentTime;
for (var k = 0; k <= 100; k++) {
	for (var i = 0; i < kicks.length; i++)
		kicks[i].trigger(now);
	now += 1 / 7.83;
}

</script>






<script>
	
var context = new AudioContext;
	console.log(context.sampleRate);
	console.log(context.destination.channelCount);
	
	
function Kick(context, freq, gainV) {
	this.context = context;
	this.freq = freq;
	this.gainV = gainV;
};

Kick.prototype.setup = function() {
	this.osc = this.context.createOscillator();
	this.gain = this.context.createGain();
	this.osc.connect(this.gain);
	this.gain.connect(this.context.destination)
};

Kick.prototype.trigger = function(time) {
	this.setup();

	this.osc.frequency.setValueAtTime(this.freq, time);
	this.gain.gain.setValueAtTime(this.gainV, time);
	//this.gain.gain.setValueAtTime(1, time);

	this.osc.frequency.exponentialRampToValueAtTime(0.01, time + 100);
	this.gain.gain.exponentialRampToValueAtTime(0.01, time + 100);

	this.osc.start(time);

	this.osc.stop(time + 100);
};

var kicks = new Array(2);

for (var i = 0; i < kicks.length; i++)
	kicks[i] = new Kick(context, 7.83 * (1 + i), 1 - i / kicks.length);
//var now = context.currentTime;
for (var i = 0; i < kicks.length; i++)
	kicks[i].trigger(now);
	

</script>


<script>
	/*
var baseFrequency = 432;
var scale1 = [
	1/1,	// 1
	16 / 15,//
	9 / 8,	// M2
	6 / 5,	//
	5 / 4,	//	M3
	4 / 3,	// p4
	3 / 2,	// p5
	8 / 5,
	5 / 3,	// M6
	16 / 9,
	15 / 8,	// M7
	2 / 1];
var scale2 = [0, 2, 4, 5, 6, 8, 10];
var mode = 0;


var chord = [1, 3, 5];
// minor
// sevenths
// etc

var intervals = [[1, 3], ...];

function noteToPoint (note) {
	var x = log (note.ratio) / log (2);
	var theta = x * 2 * Math.PI;
	return new Point (cos (theta), sin (theta));
}

function chordToPoints (chord) {
	
}

// do chordToPoints() with an interval
// use center or baseFrequency?

function eulersLine (triangle) {
	
}







// chord progression
// c     | f     | g 
// c e g | f a c | g b d
// these arpeggio leaps need to be more sparing
// need "home melody" based on steps or woven scale
// 
*/
</script>
